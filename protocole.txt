>> Etude du jeu Miko
> Précisions sur le fonctionnement
on garde une liste d'entités, créées et supprimées sur demande du serveur
chaque entité est identifiée de manière unique grâce à un "entityid" (envoyable sous forme de unsigned short)
il y a un nombre fini d'actions possibles de la part des entités, on envoit action avec entityid et byte d'action (params supplémentaires éventuellement)
on envoit assez souvent des updates des entités (plus précisément sans doute pos+vitesse)
ainsi, le niveau d'interaction des clients avec le serveur est pos et actions, qui est assez haut niveau, il faudra prendre des mesures de protection au niveau du serveur (par exemple vérifier si l'entité a la capacité de se déplacer là/d'utiliser telle action (cooldown, etc))
pour l'envoi du terrain, normalement ça se fait automatiquement, mais le client peut request du terrain en particulier (ne fonctionne pas sur le mode demande/réponse parce qu'on a pas besoin que la réponse soit envoyée en tant que réponse, elle peut etre simplement prise en compte et renvoyée ultérieurement normalement)
on va peut etre devoir, si besoin, en fonction du jeu, envoyer une requete explicite depuis le serveur pour supprimer du terrain pour aider le client à poubeller le terrain inutile au fur et à mesure
niveau implémentation, il faudra trouver moyen d'associer connection/compte à chaque socket ouvert, pour gérer envois de ping et fermeture de session de manière objet/jolie, etc.
> Protocole
Binaire, TCP
ne pas envoyer de OK/ack systématique (on est en tcp)
tout est envoyé en BIGENDIAN
str: unsigned short contentlength, utf-8 bytes
on parse tout en mode: unsigned byte d'enum puis contenu du message
contenu du message dépend de enum
par exemple message vide peut avoir 0 contenu: pas besoin de spécifier de content-length avant le message tout le temps
+ 2^7 = réponse
0:SC ping | pong
1:SC exit (un unsigned byte exit code ? (server déco/client déco/whatever))
2:C login (str pseudo, str password) | 1 unsigned byte responsecode (ok, usr inconnu, mauvais pwd, too many tries, déjà connecté, limite de joueurs atteinte, ...)
3:C register (str pseudo, str password) | 1 unsigned byte responsecode (ok, usr déjà utilisé, usr impossible, pwd impossible, too many tries, création désactivée, ...)
4:S playermeta (unsigned short entityid, unsigned byte metaaction (joined(str playername), left)
5:S terrainupdate (bytes terrain (à voir plus précisément))
6:C terrainrequest (éventuellement un hint pour où on a besoin de terrain)
7:S entitiesupdate (bytes entities (pour chaque entité, bytes de position?))
8:C entityupdate(bytes entité (celle du joueur))
9:S actions(bytes actions(eventuellement des parametres supplémentaires en fonction de l'action))
10:C action(unsigned byte action(idem))
11:S entitescreate (unsigned short entityid, bytes des params)
12:S entitiesdestroy (unsigned short entityid, peutetre bytes des params)
13:C chat(str message)
14:S chat(unsigned short entityid, str message)
# pour faire un event global, on pourra faire actions avec comme senderid un nombre spécial (unsignedshort.max_value?)
# pour faire parler un monstre, il suffit de chat avec comme entityid son id
exemple de jeu:
[initiation du ssl, session tcp établie]
S ping
C |ping
...
C login(usr,pwd)
S |login (usr inconnu)
C register(usr,pwd)
S |register(ok)
C login(usr,pwd)
S |login(ok)
S (en broadcast) playermeta(id,joined(usr))
S (en broadcast) entitiesupdate([id, bytes de pos/vitesse])
...
S ping
C |ping
...
S terrainupdate(terrain)
C entityupdate(bytes)
S (en broadcast) entitiesupdate([...])
S (en broadcast) entitiesupdate([...])
C terrainrequest(hint)
S terrainupdate(terrain)
...
C chat("cc")
S (en broadcast) (id, "cc")
...
C ping
S |ping
...
C action(action)
S (en broadcast) actions(...)
...
S exit(server exit/player bannedmdr) OU C exit(player quit) S (broadcast) entitiesdestroy(id) S (broadcast) playermeta(id, left)
[celui qui a envoyé exit peut fermer direct le stream, celui qui le reçoit peut fermer direct le stream]
fin d'exemple de jeu
c'est assez général comme protocole, mais il faudra assez spécifier les bytes de action/terrain/entité
de manière générale, les commandes qui ont une réponse sont envoyées en attendant la réponse
le ping peut se résumer à j'envois un ping si j'ai pas reçu de message depuis 5 secondes, et si j'ai rien pendant 10 secondes d'affilée (en tout) je exit(ping timeout)
paramètres à faire varier: fréquence d'envoi de entitiesupdate/entityupdate, du terrain (même si il est invariant, on peut dire qu'on envoit par plus petits morceaux mais plus souvent, voir plus précisément en testant), timeout du ping, et quelques autres trucs plus précis dont il faudra parler liés à l'optimisation du multijoueur
le serveur attend avant d'envoyer des entitiesupdate, par exemple il le fait toutes les n frames, il ne l'envoit pas dès qu'il reçoit une update
-
finalement, puisque peu de messages admettent une réponse, autant hardcoder les messages avec réponse
---
si l'on juge l'amour par ses effets, il ressemble plus à la haine qu'à de l'amitié ~ rochefoucauld
UNE VIOLENCE des passions
la même jalousie, la même fureur, la même VIOLENCE
---
terrain
exemple :
  y
  ^
  | M
  |
-+--> x
  | M
avec M un bloc étant un mur
on peut l'imaginer comme un tableau infini de booléens, un booléen en chaque case, true si c'est un bloc de mur
on peut l'imaginer comme une liste infinie de cases de murs (où on stocke leurs coordonnées)
si dans le futur, on a besoin de plus de possibilités pour décrire l'état d'une case (au-delà de mur/pas mur), on pourra envoyer un byte avec chaque coordonnée de case pour spécifier le type de case particulier (et on se mettra d'accord sur une valeur spéciale du byte qui correspond à la valeur de la case si on ne l'envoit pas)
terrainupdate: on envoit un bloc de 256x256 cases
2 short : coordonnées du coin en bas à gauche du bloc (multiple de 256 en X et en Y)
unsigned short : nombre de murs
(nombre de murs) fois:
	2 unsigned byte : coordonnées de la case dans le bloc par rapport au coin en bas à gauche
finterrainupdate
il peut être plus optimisé de l'envoyer comme ça:
2 short : coordonnées du coin en bas à gauche du bloc
256x256 fois:
	bit/byte: valeur de la case aux coordonnées (i%256,i//256)
	# bit si mur/pas mur ; byte si on a besoin d'un byte pour stocker l'état du message
finplusoptimisé
la valeur critique de la quantité de murs à partir duquel c'est plus efficace de l'envoyer selon la seconde méthode est :
si on peut le stocker par un bit : 4096 murs par bloc, ie un mur toutes les 16 cases
si on peut le stocker par un byte: 21845 cases spéciales par bloc, ie une case différent de la case standard toutes les 3 cases
peut-être que ce sera utile de pouvoir jongler entre les deux et du coup d'ajouter un bit au début du message spécifiant si il est envoyé selon la première ou la seconde méthode (qui sera pad à un byte entier puisqu'on lit byte par byte), en attendant on utilisera la première méthode
notes d'implémentation: ça risque d'être assez difficile à implémenter: comment gérer les collisions efficacement, comment gérer les murs efficacement ? puisque l'espace mémoire n'est pas critique, il faut privilégier la facilité de programmation (contrairement à quand on envoit par réseau). je pense que ça peut être intéressant de garder le système de segmentation par bloc, parce que ça permettera de "naturellement" filtrer les murs à observer lors d'une collision/d'un affichage, vu qu'on n'aura qu'à s'intéresser à tous ceux d'un bloc donné (éventuellement, il faudrait peut-être, dans le cas où on se retrouverait avec une grande quantité de cases non standard, séparer une liste avec toutes les cases non standard, et une avec juste celles qui interviennent dans les collisions, pour itérer plus vite dans la liste de cases lorsqu'il y a une collision)
(là encore, c'est très général, mais ça permet justement d'étendre le protocole à souhait, en rajoutant une valeur à chaque byte)
concrètement, dans le modèle bit/case, on aura simplement mur/pas mur ; et dans le modèle byte/case, on pourra associer une tile à chaque case (qui peut correspondre à une image et à un booléen mur/pas mur). gardons le modèle bit pour l'instant
-
entités
il est très difficile de faire un joli système d'entités (et je ne parle même pas de l'implémentation, mais juste du protocole)
chaque entité a un entityid, une position
éventuellement une vitesse (négligeons l'accélération pour l'instant)
la position sera envoyée en coordonnées cartésiennes, la vitesse en coordonnées _polaires_
ie, (x,y,normevitesse,anglevitesse)
(on a besoin d'envoyer la vitesse pour faire l'extrapolation (et l'interpolation) des coordonnées des entités entre chaque frame reçue)
on a pas besoin de précision extrême sur l'angle de la vitesse ou sur sa norme, on enverra donc des _float_
note d'implémentation: il vaudrait mieux stocker l'angle et la norme sous forme de double pour mieux gérer une accélération éventuelle, mais pas besoin d'autant de précision dans l'envoi puisqu'on mettra à jour suffisament souvent pour corriger les défauts de trajectoire liées aux imprécisions
ie (short, short, float, float)
je propose le système suivant:
pour chaque entité à update: #les entités qui ne sont pas updatées continuent à agir normalement
	1 unsigned short : entityid
	1 byte de BITFIELD qui spécifie les données à update à ce tour ci sur cette entité
	pour chaque bit de bitfield, de gauche à droite:
		lire depuis le stream les choses à update pour ce bit
		# exemple: pour le bit position on lira deux short, x puis y
bitfield : position ; anglevitesse ; normevitesse ; unused ; unused ; unused ; unused ; unused
il est extensible au sens où on pourra ajouter des valeurs au bitfield
il est efficace parce qu'on enverra à chaque fois que ce qui a besoin d'être update pour chaque entité
pour les caractéristiques des entités qui sont les mêmes pendant toute la durée de vie de l'entité, on préfèrera les envoyer par entitycreate au moment de la création
notes d'implémentation: comment représenter une entité, avec son image et toutes les caractéristiques supplémentaires ? on peut pour l'instant associer un unsgined byte à chaque entité qui correspond à une image, et un unsigned byte qui correspond à son TYPE (joueur ? ennemi ? piège ? interrupteur ? ... ). clairement on aura besoin de caractéristiques supplémentaires pour certains types d'entités, on pourra utiliser éventuellement un système d'héritage avec des classes, mais ça risque de devenir assez lourd, peut etre un héritage par interface? mais ça reste lourd, il faudra aviser. 
Puisque le type d'entité restera constant tout au long de son temps de vie, on enverra son type avec ses caractéristiques supplémentaires pendant entitycreate. 
Il faudra envoyer des caractéristiques supplémentaires en fonction du type de l'entité, au fur et à mesure de son temps de vie, imagine un interrupteur qui passe en mode activé, ou un monstre qui prend une animation particulière lorsqu'il envoit un projectile, ou lorsqu'il dash, ... je propose d'ajouter un bit au bitfield, qui permettra d'ajouter des paramètres spécifiques au type de l'objet
d'où : bitfield : position ; anglevitesse ; normevitesse ; unused ; unused ; unused ; unused ; caracssupplémentaires
et les bytes de caracssupplémentaires seront :
	1 byte de BITFIELD spécifiant les choses à update
	#dépendent du type de l'entité (le serveur et le client connaissent déjà le type de l'entité donc pas besoin de le renvoyer
	#par exemple pour un interrupteur on peut imaginer le bitfield : activé ; unused ; unused ; unused ; unused ; unused ; unused ; unused
	pour chaque bit de bitfield, lire des bytes du stream
	# pour l'interrupteur par exemple on lira un bit (en fait paddé à un byte puisqu'on lit byte par byte) qui correspond à son état d'activation
pour spécifier plus loin, il faudrait donner les types d'entités, et les caractéristiques supplémentaires de chaque type d'entités, et alors on spécifierait entitycreate assez facilement
pour entitesdestroy, il faudrait peut etre garder ça assez minimal, par exemple si la mort d'un personnage crée une explosion, il faudrait peut etre faire spawn une entité explosion, en tous cas déléguer les taches complexes à d'autres choses que entitiesdestroy qui devrait vraiment être minimaliste et générique